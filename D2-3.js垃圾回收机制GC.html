<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 内存的生命周期
        // JS环境中分配的内存,一般有如下生命周期:
        // 1. 内存分配:当我们声明变量、函数、对象的时候,系统会自动为他们分配内存
        // 2. 内存使用:即读写内存,也就是使用变量、函数等 
        // 3. 内存回收:使用完毕,由垃圾回收器自动回收不再使用的内存
        // 为变量分配内存 
        const age = 18
        // 为对象分配内存 
        const obj = { age: 19}
        // 为函数分配内存 
        function fn() {
             const age = 18 
             console. log(age)
        }
        // 全局变量一般不会回收(关闭页面回收)
        // 一般情况下局部变量的值,不用了,会被自动回收掉
        // 内存泄漏:程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏
        
        // 堆栈空间分配区别:
        // 1. 栈(操作系统):由操作系统自动分配释放函数的参数值、局部变量等,基本数据类型放到栈里面。
        // 2. 堆(操作系统):一般由程序员分配释放,若程序员不释放,由垃圾回收机制回收。复杂数据类型放到堆里面。
        // 下面介绍两种常见的浏览器垃圾回收算法:引用计数法 和 标记清除法
   
        // 引用计数
        // IE采用的引用计数算法,定义“内存不再使用”,就是看一个对象是否有指向它的引用,没有引用了就回收对象
        // 算法:
        // 1. 跟踪记录被引用的次数
        // 2. 如果被引用了一次,那么就记录次数1,多次引用会累加 ++ >
        // 3. 如果减少一个引用就减1 --
        // 4. 如果引用次数是0,则释放内存
        // 问题：嵌套引用（循环引用）：两个对象相互引用，垃圾回收不会回收，导致内存泄漏
        // 这样的相互引用大量存在会导致大量的内存泄漏
        function fn1(){
            let obj1 = {}
            let obj2 = {}
            obj1.a = obj2
            obj2.a = obj1
            return
        }
        fn()
        
        // 另一种垃圾回收机制 标记清除法
        // 现代浏览器大多基于标记清除法改进
        // 核心:
        // 1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”
        // 2. 就是从根部(在JS中就是全局对象)出发定时扫描内存中的对象。凡是能从根部到达的对象,都是还需要使用的。
        // 3. 那些无法由根部出发触及到的对象被标记为不再使用,稍后进行回收。
        // 总的来说就是：从根部（js全局变量）开始扫描，能查找到就是使用的，查找不到就是要回收的
        


    </script>
</body>
</html>